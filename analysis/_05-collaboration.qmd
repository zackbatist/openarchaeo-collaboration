# Collaborative practices {#sec-collaboration}

```{r data-oarch_github}
# Subset of dataset with GitHub data
oarch |> 
  filter(!is.na(gh_repo_info)) ->
  oarch_gh
```

As well as hosting source code, GitHub and other software forges include systems for facilitating collaboration on code and other projects.
The basic collaborative workflow is inherited from git, which allows multiple users to commit code to the repository (see @tbl-glossary for definitions of this and other git terminology used in this section).
A user with commit access to a repository can change any of its contents at will, so this is usually reserved for the project maintainer and known, trusted collaborators.
GitHub extends this model with its pull request feature, by which any user can fork a repository to which they don't have commit access, make changes, then offer to contribute those changes back to the original repository.
The maintainer can choose to merge (accept) or decline the pull request, facilitating contributions from a wider network of collaborators without the need for permission to be sought in advance.

```{r fig-lifespan}
#| fig-cap: Lifespan of repositories. Each point indicates a commit; excludes repositories with only one commit.
oarch_gh |>
  unnest(gh_commits) |>
  drop_na(datetime) |>
  filter(datetime > ymd("2001-01-02")) |> # Apparent error
  group_by(item_name) |>
  add_tally() |>
  filter(n > 1) |>
  mutate(
    first_commit = min(datetime, na.rm = TRUE),
    mid_commit = median(datetime, na.rm = TRUE),
    last_commit = max(datetime, na.rm = TRUE)
  ) |>
  ggplot(aes(x = fct_reorder(item_name, last_commit, .desc = FALSE),
             y = datetime,
             ymin = first_commit,
             ymax = last_commit)) +
  geom_linerange(linewidth = 0.05) +
  geom_point(size = 0.1) +
  scale_y_datetime(date_breaks = "2 years", date_labels = "%Y") +
  labs(x = NULL, y = NULL) +
  theme_oarch() +
  theme(
    axis.line.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.x = element_blank(),
    panel.grid.minor.x = element_blank(),
    panel.grid.major.x = element_blank()
  )
```

```{r data-oarch_lifespan}
oarch_gh %>% 
  unnest(gh_commits) %>% 
  drop_na(datetime) %>% 
  group_by(item_name) %>%
  mutate(n_contribs = map_int(gh_contribs, vctrs::vec_size)) %>% 
  summarise(
    category = first(category),
    n_contribs = first(n_contribs),
    n = n(),
    first_commit = min(datetime),
    last_commit = max(datetime),
    lifespan = as.integer(last_commit - first_commit),
    commit_rate = n / lifespan
  ) |>
  mutate(commit_rate = if_else(is.finite(commit_rate), commit_rate, NA)) ->
  oarch_lifespan

# Statistics
n_1commit <- nrow(filter(oarch_lifespan, n == 1))

p_lifespan_30days <- nrow(filter(oarch_lifespan, lifespan < 30)) / nrow(oarch_lifespan)
p_lifespan_90days <- nrow(filter(oarch_lifespan, lifespan < 90)) / nrow(oarch_lifespan)
p_lifespan_365days <- nrow(filter(oarch_lifespan, lifespan < 365)) / nrow(oarch_lifespan)

oarch_lifespan |>
  arrange(-lifespan) |>
  slice(1:10) |>
  pull(lifespan) |>
  range() ->
  lifespan_top10_range

max_commit_rate <- max(oarch_lifespan$commit_rate, na.rm = TRUE)
p_commit_rate_1 <- nrow(filter(oarch_lifespan, commit_rate < 1)) / nrow(oarch_lifespan)
```

We measured the lifespan of a repository as the time between the first and latest commit, and its activity as the rate of commits.
Here therefore we refer to the *development* lifespan of a project, which is not necessary related to its use-life.
By these metrics, the lifespan and activity of repositories in open-archaeo vary greatly (@fig-lifespan).
The average project lasts `r round(mean(oarch_lifespan$lifespan))` days with `r round(mean(oarch_lifespan$commit_rate, na.rm = TRUE), 2)` commits per day.
Many projects are active for only a short period of time: about `r percent(p_lifespan_30days)` less than 30 days, `r percent(p_lifespan_90days)` less than 90 days, and `r percent(p_lifespan_365days)` less than a year.
However, the vast majority (all but `r english(n_1commit)`) do have more than one commit, suggesting that use of GitHub as a pure host for already-finished projects is not common; some degree of iteration, if not collaboration, is almost always present.
The longest-lived projects have been active for between `r english(round(lifespan_top10_range / 365)[1])` and `r english(round(lifespan_top10_range / 365)[2])` years.
The most active projects see up to `r round(max_commit_rate)` commits per day, but the majority of repositories (`r percent(p_commit_rate_1)`) receive less one commit per day.

```{r fig-lifespan-rate}
#| fig-cap: Lifespan, commit rate and contributors to repositories. Note that both scales are logarithmic.
# TODO: add marginal histograms?
oarch_lifespan %>%
  ggplot(aes(x = lifespan, y = commit_rate, size = n_contribs)) +
  geom_point(shape = 21, colour = "black", fill = alpha("black", 0.3)) +
  scale_x_log10() +
  scale_y_log10() +
  labs(x = "Lifespan (days)", y = "Commits per day", size = "Contributors") +
  theme_oarch()
```

The interaction between project longevity, activity, and number of contributors is multifaceted [@fig-lifespan-rate].
Highly active projects (one commit per day or more) tend to be either very long-lived or very short-lived; few fall in the centre of the distribution.
Short-lived projects tend to be characterised by a 'spree' of activity (a high commit rate), while long-lived projects have a broader range of activity profiles.
The most "successful" projects according to open source norms (i.e. long-lived and active) are with few exceptions those projects with the largest contributor base in our dataset.
However, the modal project in the centre of the distribution is more modest, lasting around three years, maintained as by an individual or a small group, with around three commits per month.

```{r data-collab-features}
oarch_gh |> 
  hoist(gh_repo_info, "stars", "forks", .remove = FALSE) |>
  mutate(
    issues = map_int(gh_issues, \(x) if(is.data.frame(x)) nrow(x) else 0),
    comments = map_int(gh_comments, \(x) if (is.data.frame(x)) nrow(x) else 0)
  ) ->
  oarch_gh

p_with_issues <- n_filter(oarch_gh, issues > 0) / nrow(oarch_gh)
p_with_one_issue <- n_filter(oarch_gh, issues == 1) / n_filter(oarch_gh, issues > 0)
p_with_few_issues <- n_filter(oarch_gh, issues > 0 & issues <= 10) / n_filter(oarch_gh, issues > 0)

p_with_forks <- n_filter(oarch_gh, forks > 0) / nrow(oarch_gh)
p_with_stars <- n_filter(oarch_gh, stars > 0) / nrow(oarch_gh)

oarch_gh |> 
  select(-description, -comments) |> 
  unnest(gh_issues) |>
  drop_na(comments) |>
  count(comments > 0) |>
  mutate(p = n / sum(n)) |>
  filter(`comments > 0`) |>
  pull(p) ->
  p_issues_with_comments 
```

```{r fig-collab-features}
#| fig-cap: Use of GitHub collaboration features (forks, issues, comments, stars) across repositories
oarch_gh |>
  pivot_longer(c(forks, issues, comments, stars), 
               names_to = "feature", values_to = "n") |>
  mutate(
    feature = factor(feature, c("stars", "comments", "issues", "forks")),
    feature = recode(feature, issues = "Issues and pull requests"),
    feature = fct_relabel(feature, str_to_sentence)
  ) |>
  ggplot(aes(n, feature)) +
  geom_boxplot() +
  scale_x_log10() +
  labs(x = NULL, y = NULL) +
  theme_oarch()
```

GitHub also facilitates collaboration on broader project management tasks, primarily through its issues feature.^[Apart from issues, GitHub has a very wide range of project management and social media-like features, including wikis, discussion forums and 'kanban' boards. We have not analysed the use of these features here.]
Unless a repository's maintainer specifically configures it otherwise, any user can create an issue attached to another user's repository, or comment on an existing issue.
Issues are typically used to log and track bug reports, feature requests, and other comments and suggestions from the project's user base.
GitHub's pull request feature is also implemented via this system â€“ a pull request is a special type of issue.
According to the data we collected from the GitHub API, these features are not widely used by open-archaeo projects (@fig-collab-features).
Only `r percent(p_with_forks)` of repositories have been forked at least once and only `r percent(p_with_issues)` of repositories make use of issues/pull requests.
Those repositories that do use issues do not not use them very extensively; `r percent(p_with_one_issue)` have only one issue and `r percent(p_with_few_issues)` have ten or less. 

Another way GitHub users can engage with repositories and other users is with social media-like features such as starring a repository, commenting on an existing issue, or following a user.
These actions populate a timeline of through which users can see recent activity and discover new projects related to those they have interacted with in the past.^[This feature of GitHub's timeline was one of the primary ways we compiled open-archaeo.]
While not as a direct a contribution as pull requests or issues, these features can facilitate the formation and maintenance of collaborative networks, in the same way that other social media platforms serve other professional networks.
These features are used more widely than forks, issues and pull requests (@fig-collab-features): `r percent(p_with_stars)` of repositories have at least one star and, in those repositories that use issues, `r percent(p_issues_with_comments)` of them has received at least one additional comment.

```{r data-contributions}
oarch_contributions <- oarch_gh |>
  unnest(gh_contribs) |>
  drop_na(contributor) |>
  group_by(item_name) |>
  summarise(n_contributors = n())

p_one_contrib <- n_filter(oarch_contributions, n_contributors == 1) / nrow(oarch_contributions)

oarch_contribs_by_repo <- oarch_gh |>
  unnest(gh_contribs) |>
  drop_na(contributor) |>
  group_by(item_name) |>
  mutate(n_contributors = n()) |>
  filter(n_contributors > 1) |>
  mutate(big_boy = ifelse(contributions == max(contributions),
                          "Leading contributor", "Other contributors")) |> 
  group_by(item_name, big_boy) |>
  summarise(contributions = sum(contributions)) |>
  mutate(
    p_contributions = contributions / sum(contributions),
    p_big_boy = first(p_contributions)
  ) |>
  ungroup()

p_big_boy_50 <- n_filter(oarch_contribs_by_repo, p_big_boy > 0.5) / nrow(oarch_contribs_by_repo)
p_big_boy_75 <- n_filter(oarch_contribs_by_repo, p_big_boy > 0.75) / nrow(oarch_contribs_by_repo)
```


```{r fig-contributions}
#| fig-cap: Distribution of contributions in multi-contributor projects
oarch_contribs_by_repo |>
  mutate(item_name = fct_reorder(item_name, p_big_boy, .desc = TRUE)) |> 
  ggplot(aes(x = item_name, y = contributions,
             fill = ordered(big_boy, c("Other contributors", "Leading contributor")))) +
  geom_col(position = "fill", linewidth = 0, width = 1) +
  geom_hline(yintercept = c(0.25, 0.5, 0.75), alpha = 0.5) +
  scale_y_continuous(labels = scales::percent) +
  scale_fill_highcontrast() +
  labs(x = "Individual repositories", y = "Contributions", fill = NULL) +
  theme_oarch() +
  theme(
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
  )
```

Perhaps unsurprisingly, given the low uptake of GitHub's collaborative features, `r percent(p_one_contrib)` of open-archaeo repositories only contain commits from a single user.
Even in the minority of projects that have more than one contributor, work (as measured by number of recorded commits) is distributed highly unevenly (@fig-contributions).
The lead maintainer almost always does the lion share of the work: they are responsible for more than half of commits in `r percent(p_big_boy_50)` of projects and more than three-quarters in `r percent(p_big_boy_75)`.
This may be attributed to the steep learning curve commonly attributed to working with git.
While git can be a great way to track changes and manage distributed contributions to a common code base, it can also be unwieldy in situations when multiple users (especially those with less experience using git for collaborative purposes) are expected to contribute within short spans of time.
This meshes with our prior observations that projects which tend to exhibiting higher commit rates have less contributors.
Additionally, our analyses neglects to account for contributions that are not tracked via git or GitHub.
Those who do not code may provide creative guidance or feedback during in-person meetings, via email, or using alternative online messaging or social media platforms.
A more focused qualitative assessment of these non-coding and supportive work practices would shed more light on the totality of effort that goes into producing and maintaining open source projects.

The prototypical and idyllic collaborative open source project ingrained into the common consciousness hypothetically comprises a core group of developers (often a single maintainer) that regularly commit new code, a wider network of collaborators that contribute through forks and pull requests, plus an active user base that create and comment on issues, who have indicated their support for the project by starring its repository.
It is unclear whether archaeological software developers actually aim to operate following this model, or whether it is even suitable for supporting what open science aims to achieve.
However it is clear that only a small number of open-archaeo projects operate according to this model.
The majority of projects are in fact short-lived, with few contributors and a small number of commits.
Use of GitHub's collaboration features is also generally low (@fig-collab-features), although the data also shows a divergence between the uptake of features that facilitate direct code contributions (forks, issues, pull requests), which have markedly zero-skewed distributions, versus more indirect, social media-like features (comments, stars), which are moderately well-used.
We hypothesise that this shows a preference for passive/reactive rather than active/proactive engagement with others work â€“ a point we will return to in the conclusion.


# An emerging community of practice? {#sec-network}

```{r data-oarch_contributors}
oarch |>
  unnest(gh_contribs) |>
  drop_na(contributor) |>
  group_by(contributor) |>
  mutate(
    repo_owner = if_else(str_extract(repo, "[^/]+") == contributor, "own", "other")
  ) |>
  group_by(contributor, repo_owner) |>
  summarise(repos = n(), contribs = sum(contributions), .groups = "drop_last") |>
  pivot_wider(id_cols = c(contributor), names_from = repo_owner, 
              values_from = c(repos, contribs), values_fill = 0) |>
  mutate(
    repos = repos_other + repos_own,
    contribs = contribs_other + contribs_own,
    .after = contributor
  ) ->
  oarch_contributors
```

By contributing to shared repositories—whether with code (commits), issues, or comments—archaeologists using GitHub form a collaborative network which we can map using data from the GitHub API.
Here we consider two facets of this network: repositories connected by common contributors (the repository–repository graph), and users connected by contributions to common repositories (the user–user graph).
In both cases, number of contributions constitutes a natural measure of the strength or weight of the connection, which can be further broken down by type of contribution (commit, issue/pull request, or comment).

```{r data-graph}
oarch |>
  drop_na(gh_repo) |>
  unite(tags, c(tag1, tag2, tag3, tag4, tag5)) |>
  select(gh_repo, category, tags, gh_commits, gh_issues, gh_comments) ->
  oarch_graph

oarch_graph <- bind_rows(
  oarch_graph |>
    unnest(gh_commits) |>
    drop_na(author) |> # Apparently real commits, but we can't connect them
    group_by(repo, author) |>
    summarise(contrib = "commit", n_contrib = n(), .groups = "drop"),
  oarch_graph |>
    unnest(gh_comments) |>
    drop_na(author) |> # Repos with no comments
    group_by(repo, author) |>
    summarise(contrib = "comment", n_contrib = n(), .groups = "drop"),
  oarch_graph |>
    unnest(gh_issues) |>
    drop_na(author) |> # Repos with no issues
    group_by(repo, author) |>
    summarise(contrib = "issue", n_contrib = n(), .groups = "drop")
)

# Cleaning
oarch_graph |>
  rename(user = author) |>
  # Remove non-human users
  filter(!str_detect(user, coll("[bot]"))) |>
  filter(!user %in% c("ghost", "codecov-io", "coveralls", "codecov-commenter",
                      "gitter-badger", "dependabot-support")) ->
  oarch_graph

# Repo-user
oarch_graph_repo_user <- tbl_graph(nodes_repos_users(oarch_graph),
                                   edges_user_to_repo(oarch_graph))

# Repo-repo
tbl_graph(nodes_repos(oarch_graph),
          edges_common_users(oarch_graph),
          directed = FALSE) |>
  mutate(
    degree = centrality_degree(),
    betweenness = centrality_betweenness(weights = n),
    subgraph = as_factor(group_components()),
    group = as_factor(group_edge_betweenness())
  ) ->
  oarch_graph_repo_repo

# User-user
tbl_graph(nodes = nodes_users(oarch_graph), 
          edges = edges_common_repos(oarch_graph),
          directed = FALSE) |>
  mutate(
    degree = centrality_degree(),
    betweenness = centrality_betweenness(weights = n),
    subgraph = as_factor(group_components())
  ) ->
  oarch_graph_user_user

# Network stats
graph_n_repos_total <- length(oarch_graph_repo_repo)
graph_n_users_total <- length(oarch_graph_user_user)

subgraphs_n_repos <- oarch_graph_repo_repo |>
  as_tibble() |>
  count(subgraph)

subgraphs_n_users <- oarch_graph_user_user |>
  as_tibble() |>
  count(subgraph)

clusters_n_repos <- oarch_graph_repo_repo |>
  as_tibble() |>
  count(group)

# Filter out isolates
oarch_graph_repo_repo <- filter(oarch_graph_repo_repo, degree > 1)
oarch_graph_user_user <- filter(oarch_graph_user_user, degree > 1)

# Network stats (ignoring isolates)
graph_n_repos <- length(oarch_graph_repo_repo)
graph_n_users <- length(oarch_graph_user_user)
```

```{r fig-graph-repo-user}
#| fig-cap: Interactive repository–user graph.
# TODO: is there a khroma scale that can accomodate this many groups?
g_repo_user <- oarch_graph_repo_user |>
  ggraph(layout = "graphopt", mass = 100) +
  geom_edge_link(aes(group = contrib, alpha = n_contrib)) +
  geom_point_interactive(aes(x, y, colour = node_type, tooltip = node)) + 
  scale_edge_alpha(trans = "log", guide = guide_none()) +
  scale_colour_discrete(guide = guide_none()) +
  labs(edge_alpha = "Common contributors") +
  theme(panel.background = element_rect(fill = "white"))

girafe(ggobj = g_repo_user)
```

```{r fig-graph-repo-repo}
#| fig-cap: Interactive repository–repository graph. Repositories are connected by contributions by common users, with darker edges indicating more common contributors. Node colour indicates cluster membership according to the edge–betweenness method [@girvan2002]. Excludes isolate nodes.
# TODO: is there a khroma scale that can accomodate this many groups?
g_repo_repo <- oarch_graph_repo_repo |>
  ggraph(layout = "graphopt", mass = 100) +
  geom_edge_link(aes(alpha = n)) +
  geom_point_interactive(aes(x, y, colour = group, tooltip = repo)) + 
  scale_edge_alpha(trans = "log", guide = guide_none()) +
  scale_colour_discrete(guide = guide_none()) +
  labs(edge_alpha = "Common contributors") +
  theme(panel.background = element_rect(fill = "white"))

girafe(ggobj = g_repo_repo)
```

```{r fig-graph-user-user}
#| fig-cap: Interactive user–user graph. Users are connected by contributions by common repositories, with darker edges indicating more common repositories. Node colour indicates cluster membership according to the edge–betweenness method [girvan2002]. Excludes isolate nodes.
# TODO: is there a khroma scale that can accomodate this many groups?
g_user_user <- oarch_graph_user_user |>
  filter(degree > 170) |>
  ggraph(layout = "graphopt", mass = 100) +
  geom_edge_link(aes(alpha = n)) +
  geom_point_interactive(aes(x, y, tooltip = user)) + 
  scale_edge_alpha(trans = "log", guide = guide_none()) +
  scale_colour_discrete(guide = guide_none()) +
  labs(edge_alpha = "Common repositories") +
  theme(panel.background = element_rect(fill = "white"))

girafe(ggobj = g_user_user)
```

<!-- Is there a network? How big is it? -->
Our data shows that there is a significant network of archaeologists collaborating on GitHub.
`r percent(graph_n_repos / graph_n_repos_total)` of repositories and `r percent(graph_n_users / graph_n_users_total)` of users in our dataset are connected to at least one other repository or user.
Of these, `r percent(max(subgraphs_n_repos$n) / graph_n_repos)` of repositories and `r percent(max(subgraphs_n_users$n) / graph_n_users)` of users belong to a single connected subgraph (@fig-graph-repo-repo).

<!-- Clustering within the network -->
To explore the topography of this network, we applied the edge–betweenness community detection method [@girvan2002] to delimit `r nrow(filter(clusters_n_repos, n > 1))` distinct clusters in the repository–repository network.
While many of these clusters are interconnected, some discrete components containing between 2-20 repositories appear as distinct from a primary core.
The core cluster is characterized by repositories whose contributors commit to projects other than their own, and it includes a smorgasbord of projects whose contributors share varied interests.
This indicates the formation of a central software development community rather than a focus on any specific topic of work.
The other peripheral clusters situated around the core largely correspond with the work of single individuals, and sometimes also their close colleagues.
Many of the projects represented in the core emerge from underlying professional partnerships, namely research labs (e.g. ISAA-Kiel) and special interest groups (SSLA).
Peripheral clusters that are connected to core clusters by only a few relationships represent the sole (or perhaps initial) integration of lone developers into a broader community.

```{r tbl-repo-betweenness}
#| tbl-cap: Most central repositories (weighted node betweenness) in the repository–repository network
oarch_graph_repo_repo |>
  mutate(betweenness = centrality_betweenness()) |>
  as_tibble() |>
  arrange(-betweenness) |>
  slice(1:10) |>
  left_join(oarch, c("repo" = "gh_repo")) |>
  mutate(n_commits = map_int(gh_commits, nrow)) |>
  unite(tags, tag1:tag5, sep = "; ", na.rm = TRUE) |>
  select(repo, betweenness, category, tags, n_commits) |>
  rename(repository = repo, commits = n_commits) |>
  rename_with(tools::toTitleCase) |>
  tt()
```

```{r fig-repo-betweenness-age-length}
#| fig-cap: Log-log correlation between repository centrality (weighted node betweenness), age (left) and length (right)
left <- oarch_graph_repo_repo |>
  as_tibble() |> 
  left_join(oarch, by = c("repo" = "gh_repo")) |>
  mutate(
    age = map_int(gh_commits, \(x) min(today() - date(x$datetime)))
  ) |>
  ggplot(aes(age, betweenness)) +
  geom_point() +
  scale_x_log10() +
  scale_y_log10() +
  geom_smooth(method = "glm") +
  labs(x = "Repository age (days)", y = "Centrality (betweenness)") +
  theme_oarch()

right <- oarch_graph_repo_repo |>
  as_tibble() |> 
  left_join(oarch, by = c("repo" = "gh_repo")) |>
  mutate(
    length = map_int(gh_commits, nrow)
  ) |>
  ggplot(aes(length, betweenness)) +
  geom_point() +
  scale_x_log10() +
  scale_y_log10() +
  geom_smooth(method = "glm") +
  labs(x = "Number of commits", y = NULL) +
  theme_oarch()

left + right
```

<!-- Predictors of repo centrality -->
The repositories most central to the network as a whole [@tbl-repo-betweenness] include several lists and directories, including open-archaeo itself.
Four of the top ten most central repositories (ISAAKiel/mortAAR, ISAAKiel/shapAAR, ISAAKiel/quantAAR, ropensci/c14bazAAR) are associated with the ISAA-Kiel group, emphasising the importance of existing 'real world' collaborations in structuring the network.
Three (ropensci/c14bazAAR, ahb108/rcarbon, Chronomodel/chronomodel) are R packages relating to radiocarbon data and modelling, probably reflecting the fact that this has long been a prominent focus of statistical software development in archaeology.
Repository centrality is predicted by the total number of commits it has received but, somewhat surprisingly, it is younger repositories rather than older ones that tend to be more central.
Tentatively, we interpret this as an indication that the network has become more connected over time, but we leave a fuller analysis of temporal trends in collaborative activity to future work.

```{r fig-repo-betweenness-category-platform}
#| fig-cap: Mean repository centrality (weighted node betweenness) by open-archaeo category (top) and platform (bottom)
top <- oarch_graph_repo_repo |>
  as_tibble() |> 
  left_join(oarch, by = c("repo" = "gh_repo")) |>
  group_by(category) |>
  summarise(betweenness = mean(betweenness)) |>
  mutate(category = fct_reorder(category, betweenness)) |>
  ggplot(aes(category, betweenness)) +
  geom_col() +
  scale_y_log10() +
  coord_flip() +
  labs(y = NULL, x = NULL) +
  theme_oarch()

bottom <- oarch_graph_repo_repo |>
  as_tibble() |> 
  left_join(oarch, by = c("repo" = "gh_repo")) |>
  drop_na(platform) |>
  group_by(platform) |>
  summarise(betweenness = mean(betweenness)) |>
  arrange(-betweenness) |>
  slice(1:7) |>
  mutate(platform = fct_reorder(platform, betweenness)) |>
  ggplot(aes(platform, betweenness)) +
  geom_col() +
  scale_y_log10() +
  coord_flip() +
  labs(y = "Centrality (weighted betweenness)", x = NULL) +
  theme_oarch()

top / bottom
```

The highest mean centrality is seen in repositories that contain lists/datasets, standalone software, or packages/libraries, and in repositories based on Python, R or QGIS [@fig-repo-betweenness-category-platform].
Interestingly, these trends depart from the observed popularity of different categories/platform in the open-archaeo dataset as a whole (see @sec-open-archaeology): standalone software is more central than packages/libraries, even though there are more of the latter by a significant margin.
Similarly, Python packages tend to be more central than R packages, despite being the minority language.
<!-- @ZB: I think this is interesting, but I couldn't really think of a general observation to make here. Maybe you can? -->
<!-- Possibly that R packages are easier to spin up solo, whereas standalone tends to have more financial/institutional backing, and thus greater potential to support teams of developers -->

```{r fig-user-betweenness-contribs, eval=TRUE}
#| fig-cap: Log-log correlation between user centrality (weighted node betweenness) in the user-user graph and total number of contributions
oarch_graph_user_user |>
  as_tibble() |> 
  left_join(oarch_contributors, by = c("user" = "contributor")) |>
  ggplot(aes(betweenness, contribs)) +
  geom_point() +
  scale_x_log10() +
  scale_y_log10() +
  geom_smooth(method = "glm") +
  labs(x = "Centrality (betweenness)", y = "Total contributions") +
  theme_oarch()
```

<!-- Predictors of user centrality -->
Centrality to the user–user graph is weakly predicted by a user's overall rate of activity, as measured by their total number of contributions [@fig-user-betweenness-contribs]. 
We did not collect demographic data on users that appear in our dataset, but based on our own knowledge of the community we can observe that those highly central to the network tend to be employed in (junior) academic positions, or in a few cases in cultural heritage authorities, rather than specifically as research software engineers.
Such positions tend to not to actively reward or encourage software development, at least not on a par with more traditional academic outputs [@baxter2012], and are increasingly precarious [@Cornelius-BellBell2021].
This obviously poses a serious risk to the sustainability and growth of open source software in archaeology: if the people who occupy central positions in the network cease to be active, then it is likely that the overall network would fragment.
Assessing and mitigating this risk should be a high priority for future research in this area.

<!-- TODO: this should be backed up with a table or figure. The analysis seems to have got lost somewhere. Or just cut? -->
We also applied the same betweenness centrality algorithm on a subnetwork whose links are based only on issues and comments, and not code contributions. In this subnetwork, people who commit less code have higher betweenness scores. However, many of the people with high betweenness from the graph representing all contributions also appear here. These people who appear in both of these lists have a tendency to contribute as both committers and as commenters. This list also includes a series of contributors who never or rarely commit code. Although it is out of this study's scope a qualitative analysis of issues and comments may yield more insight on the kinds of contributions that each of these participants make.

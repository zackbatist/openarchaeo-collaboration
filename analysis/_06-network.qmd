# An emerging community of practice? {#sec-network}

```{r data-oarch_contributors}
oarch |>
  unnest(gh_contribs) |>
  drop_na(contributor) |>
  group_by(contributor) |>
  mutate(
    repo_owner = if_else(str_extract(repo, "[^/]+") == contributor, "own", "other")
  ) |>
  group_by(contributor, repo_owner) |>
  summarise(repos = n(), contribs = sum(contributions), .groups = "drop_last") |>
  pivot_wider(id_cols = c(contributor), names_from = repo_owner, 
              values_from = c(repos, contribs), values_fill = 0) |>
  mutate(
    repos = repos_other + repos_own,
    contribs = contribs_other + contribs_own,
    .after = contributor
  ) ->
  oarch_contributors
```

By contributing to shared repositories—whether with code (commits), issues, or comments—archaeologists using GitHub form a collaborative network which we can map using data from the GitHub API.
Here we consider two facets of this network: repositories connected by common contributors (the repository–repository graph), and users connected by contributions to common repositories (the user–user graph).
In both cases, number of contributions constitutes a natural measure of the strength or weight of the connection, which can be further broken down by type of contribution (commit, issue/pull request, or comment).

```{r data-graph}
oarch |>
  drop_na(gh_repo) |>
  unite(tags, c(tag1, tag2, tag3, tag4, tag5)) |>
  select(gh_repo, category, tags, gh_commits, gh_issues, gh_comments) ->
  oarch_graph

oarch_graph <- bind_rows(
  oarch_graph |>
    unnest(gh_commits) |>
    drop_na(author) |> # Apparently real commits, but we can't connect them
    group_by(repo, author) |>
    summarise(contrib = "commit", n_contrib = n(), .groups = "drop"),
  oarch_graph |>
    unnest(gh_comments) |>
    drop_na(author) |> # Repos with no comments
    group_by(repo, author) |>
    summarise(contrib = "comment", n_contrib = n(), .groups = "drop"),
  oarch_graph |>
    unnest(gh_issues) |>
    drop_na(author) |> # Repos with no issues
    group_by(repo, author) |>
    summarise(contrib = "issue", n_contrib = n(), .groups = "drop")
)

# Cleaning
oarch_graph |>
  rename(user = author) |>
  # Remove non-human users
  filter(!str_detect(user, coll("[bot]"))) |>
  filter(!user %in% c("ghost", "codecov-io", "coveralls", "codecov-commenter",
                      "gitter-badger", "dependabot-support")) ->
  oarch_graph

# Repo-user
tbl_graph(nodes_repos_users(oarch_graph),
          edges_user_to_repo(oarch_graph),
          directed = FALSE) |>
          mutate(
            degree = centrality_degree(),
            betweenness = centrality_betweenness(),
            subgraph = as_factor(group_components()),
            group = as_factor(group_edge_betweenness())
            ) ->
            oarch_graph_repo_user

# Repo-repo
tbl_graph(nodes_repos(oarch_graph),
          edges_common_users(oarch_graph),
          directed = FALSE) |>
  mutate(
    degree = centrality_degree(),
    betweenness = centrality_betweenness(weights = n),
    subgraph = as_factor(group_components()),
    group = as_factor(group_edge_betweenness())
  ) ->
  oarch_graph_repo_repo

# User-user
tbl_graph(nodes = nodes_users(oarch_graph), 
          edges = edges_common_repos(oarch_graph),
          directed = FALSE) |>
  mutate(
    degree = centrality_degree(),
    betweenness = centrality_betweenness(weights = n),
    subgraph = as_factor(group_components())
    # group = as_factor(group_edge_betweenness()) # <- very slow!
  ) ->
  oarch_graph_user_user

# Network stats
graph_n_repos_total <- length(oarch_graph_repo_repo)
graph_n_users_total <- length(oarch_graph_user_user)

subgraphs_n_repos <- oarch_graph_repo_repo |>
  as_tibble() |>
  count(subgraph)

subgraphs_n_users <- oarch_graph_user_user |>
  as_tibble() |>
  count(subgraph)

clusters_n_repos <- oarch_graph_repo_repo |>
  as_tibble() |>
  count(group)

# Filter out isolates
oarch_graph_repo_repo <- filter(oarch_graph_repo_repo, degree > 1)
oarch_graph_user_user <- filter(oarch_graph_user_user, degree > 1)

# Network stats (ignoring isolates)
graph_n_repos <- length(oarch_graph_repo_repo)
graph_n_users <- length(oarch_graph_user_user)

# Export as gexf
write.gexf(igraph.to.gexf(oarch_graph_repo_user), 
           output = here("analysis/data/derived_data/oarch_repo_user.gexf"))
write.gexf(igraph.to.gexf(oarch_graph_repo_repo), 
           output = here("analysis/data/derived_data/oarch_repo_repo.gexf"))
write.gexf(igraph.to.gexf(oarch_graph_user_user), 
           output = here("analysis/data/derived_data/oarch_user_user.gexf"))
```

```{r fig-graph-repo-user, eval=FALSE}
#| fig-cap: Interactive repository–user graph.
# TODO: is there a khroma scale that can accomodate this many groups?
g_repo_user <- oarch_graph_repo_user |>
  ggraph(layout = "fr", repulserad = 10, area = 10000, niter = 5000, grid = "nogrid") +
  geom_edge_link(aes(group = contrib, alpha = n_contrib)) +
  geom_point_interactive(aes(x, y, colour = group, shape=node_type, tooltip = node)) + 
  scale_edge_alpha(trans = "log", guide = guide_none()) +
  scale_colour_discrete(guide = guide_none()) +
  labs(edge_alpha = "Common contributors") +
  theme(panel.background = element_rect(fill = "white"))

girafe(ggobj = g_repo_user)
```

```{r fig-graph-repo-repo, eval=FALSE}
#| fig-cap: Interactive repository–repository graph. Repositories are connected by contributions by common users, with darker edges indicating more common contributors. Node colour indicates cluster membership according to the edge–betweenness method [@girvan2002]. Excludes isolate nodes.
# TODO: is there a khroma scale that can accomodate this many groups?
g_repo_repo <- oarch_graph_repo_repo |>
  ggraph(layout = "graphopt", mass = 100) +
  geom_edge_link(aes(alpha = n)) +
  geom_point_interactive(aes(x, y, colour = group, tooltip = repo)) + 
  scale_edge_alpha(trans = "log", guide = guide_none()) +
  scale_colour_discrete(guide = guide_none()) +
  labs(edge_alpha = "Common contributors") +
  theme(panel.background = element_rect(fill = "white"))

girafe(ggobj = g_repo_repo)
```

```{r fig-graph-user-user, eval=FALSE}
#| fig-cap: Interactive user–user graph. Users are connected by contributions by common repositories, with darker edges indicating more common repositories. Node colour indicates cluster membership according to the edge–betweenness method [girvan2002]. Excludes isolate nodes.
# TODO: is there a khroma scale that can accomodate this many groups?
g_user_user <- oarch_graph_user_user |>
  filter(degree > 170) |>
  ggraph(layout = "fr", repulserad = 10, area = 100000, niter = 10000000, grid = "nogrid") +
  geom_edge_link(aes(alpha = n)) +
  geom_point_interactive(aes(x, y, tooltip = user)) + 
  scale_edge_alpha(trans = "log", guide = guide_none()) +
  scale_colour_discrete(guide = guide_none()) +
  labs(edge_alpha = "Common repositories") +
  theme(panel.background = element_rect(fill = "white"))

girafe(ggobj = g_user_user)
```

<!-- Is there a network? How big is it? -->
Our data shows that there is a significant network of archaeologists collaborating on GitHub.
`r percent(graph_n_repos / graph_n_repos_total)` of repositories and `r percent(graph_n_users / graph_n_users_total)` of users in our dataset are connected to at least one other repository or user.
Of these, `r percent(max(subgraphs_n_repos$n) / graph_n_repos)` of repositories and `r percent(max(subgraphs_n_users$n) / graph_n_users)` of users belong to a single connected subgraph (@fig-graph-repo-repo and @fig-graph-user-user).

<!-- Clustering within the network -->
To explore the topography of this network, we applied the edge–betweenness community detection method [@girvan2002] to delimit `r nrow(filter(clusters_n_repos, n > 1))` distinct clusters in the repository–repository network.
While many of these clusters are interconnected, some discrete components containing between 2-20 repositories appear as distinct from a primary core.
The core cluster is characterized by repositories whose contributors commit to projects other than their own, and it includes a smorgasbord of projects whose contributors share varied interests.

Likewise, we applied the same edge-betweenness community detection method to identify clusters in the user-user network, which reveal collaborative groupings.
We again see a complementary primary core connected to several more peripheral clusters, which are internally-cohesive and exhibit few connections with other peripheral clusters.
The central core bridges all the peripheral clusters.
The central core is not uniform, and comprises several relatively discrete sub-groups representing collaborative sub-communities.
While these sub-groups are internally cohesive, they exhibit enough connections to other members of the central core so as to not be considered as separate or peripheral clusters.

In both the repository-repository and user-user networks, the peripheral clusters correspond with either the connections surrounding specific projects or the series of repositories created by single individuals and sometimes also their close colleagues.
On the other hand, the central cores exhibit greater internal variety that may correspond with social connections and the formation of a complex software development community.
This is evident through the fact that many of the connections represented in the cores emerge from underlying professional partnerships, namely research labs (e.g. ISAA-Kiel) and special interest groups (CAA-SSLA).
Peripheral clusters that are connected to the central core by only a few relationships represent the sole (or perhaps initial) integration of lone developers into a broader community.

```{r tbl-repo-betweenness}
#| tbl-cap: Most central repositories (weighted node betweenness) in the repository–repository network
oarch_graph_repo_repo |>
  mutate(betweenness = centrality_betweenness()) |>
  as_tibble() |>
  arrange(-betweenness) |>
  slice(1:10) |>
  left_join(oarch, c("repo" = "gh_repo")) |>
  mutate(n_commits = map_int(gh_commits, nrow)) |>
  unite(tags, tag1:tag5, sep = "; ", na.rm = TRUE) |>
  select(repo, betweenness, category, tags, n_commits) |>
  rename(repository = repo, commits = n_commits) |>
  rename_with(tools::toTitleCase) |>
  tt()
```

```{r fig-repo-betweenness-age-length}
#| fig-cap: Log-log correlation between repository centrality (weighted node betweenness), age (left) and length (right)
left <- oarch_graph_repo_repo |>
  as_tibble() |> 
  left_join(oarch, by = c("repo" = "gh_repo")) |>
  mutate(
    age = map_int(gh_commits, \(x) min(today() - date(x$datetime)))
  ) |>
  ggplot(aes(age, betweenness)) +
  geom_point() +
  scale_x_log10() +
  scale_y_log10() +
  geom_smooth(method = "glm") +
  labs(x = "Repository age (days)", y = "Centrality (betweenness)") +
  theme_oarch()

right <- oarch_graph_repo_repo |>
  as_tibble() |> 
  left_join(oarch, by = c("repo" = "gh_repo")) |>
  mutate(
    length = map_int(gh_commits, nrow)
  ) |>
  ggplot(aes(length, betweenness)) +
  geom_point() +
  scale_x_log10() +
  scale_y_log10() +
  geom_smooth(method = "glm") +
  labs(x = "Number of commits", y = NULL) +
  theme_oarch()

left + right
```

<!-- Predictors of repo centrality -->
The repositories most central to the network as a whole [@tbl-repo-betweenness] include several lists and directories, including open-archaeo itself.
Four of the top ten most central repositories (ISAAKiel/mortAAR, ISAAKiel/shapAAR, ISAAKiel/quantAAR, ropensci/c14bazAAR) are associated with the ISAA-Kiel group, emphasising the importance of existing 'real world' collaborations in structuring the network.
Three (ropensci/c14bazAAR, ahb108/rcarbon, Chronomodel/chronomodel) are R packages relating to radiocarbon data and modelling, probably reflecting the fact that this has long been a prominent focus of statistical software development in archaeology.
Repository centrality is predicted by the total number of commits it has received but, somewhat surprisingly, it is younger repositories rather than older ones that tend to be more central.
Tentatively, we interpret this as an indication that the network has become more connected over time, but we leave a fuller analysis of temporal trends in collaborative activity to future work.

```{r fig-repo-betweenness-category-platform}
#| fig-cap: Mean repository centrality (weighted node betweenness) by open-archaeo category (top) and platform (bottom)
top <- oarch_graph_repo_repo |>
  as_tibble() |> 
  left_join(oarch, by = c("repo" = "gh_repo")) |>
  group_by(category) |>
  summarise(betweenness = mean(betweenness)) |>
  mutate(category = fct_reorder(category, betweenness)) |>
  ggplot(aes(category, betweenness)) +
  geom_col() +
  scale_y_log10() +
  coord_flip() +
  labs(y = NULL, x = NULL) +
  theme_oarch()

bottom <- oarch_graph_repo_repo |>
  as_tibble() |> 
  left_join(oarch, by = c("repo" = "gh_repo")) |>
  drop_na(platform) |>
  group_by(platform) |>
  summarise(betweenness = mean(betweenness)) |>
  arrange(-betweenness) |>
  slice(1:7) |>
  mutate(platform = fct_reorder(platform, betweenness)) |>
  ggplot(aes(platform, betweenness)) +
  geom_col() +
  scale_y_log10() +
  coord_flip() +
  labs(y = "Centrality (weighted betweenness)", x = NULL) +
  theme_oarch()

top / bottom
```

The highest mean centrality is seen in repositories that contain lists/datasets, standalone software, or packages/libraries, and in repositories based on Python, R or QGIS [@fig-repo-betweenness-category-platform].
Interestingly, these trends depart from the observed popularity of different categories/platform in the open-archaeo dataset as a whole (see @sec-open-archaeology): standalone software is more central than packages/libraries, even though there are more of the latter by a significant margin.
This may be due to the fact that many packages are developed to support specific practices or use-cases (often inspired by personal need), or are designed to run relatively stable statistical functions that need not change over time.
These are therefore relatively stable and require little additional input after release.
On the other hand, as discussed in @sec-open-archaeology, standalone software tend to integrate multiple system components and may evolve over time to add new features or support new workflows.
Moreover, standalone software are generally rooted in longer-term and community-held objectives, and their development may therefore be backed by insitutions with funding and resources to support developers.

Despite being the minority language, Python packages tend to be more central than R packages, on average.
This might relate to the different ways in which R and Python developers call dependencies ???
<!-- @ZB: I think this is interesting, but I couldn't really think of a general observation to make here. Maybe you can? -->
<!-- I wonder what the median is? Also: cltk is a python script, and is the massive pink blob in the repo-repo and user-user networks, so that might skew things slightly -->

```{r fig-user-betweenness-contribs, eval=TRUE}
#| fig-cap: Log-log correlation between user centrality (weighted node betweenness) in the user-user graph and total number of contributions
oarch_graph_user_user |>
  as_tibble() |> 
  left_join(oarch_contributors, by = c("user" = "contributor")) |>
  ggplot(aes(betweenness, contribs)) +
  geom_point() +
  scale_x_log10() +
  scale_y_log10() +
  geom_smooth(method = "glm") +
  labs(x = "Centrality (betweenness)", y = "Total contributions") +
  theme_oarch()
```

<!-- Predictors of user centrality -->
Centrality to the user–user graph is weakly predicted by a user's overall rate of activity, as measured by their total number of contributions [@fig-user-betweenness-contribs]. 
We did not collect demographic data on users that appear in our dataset, but based on our own knowledge of the community we can observe that those highly central to the network tend to be employed in (junior) academic positions, or in a few cases in cultural heritage authorities, rather than specifically as research software engineers.
Such positions tend to not to actively reward or encourage software development, at least not on a par with more traditional academic outputs [@baxter2012], and are increasingly precarious [@Cornelius-BellBell2021].
This obviously poses a serious risk to the sustainability and growth of open source software in archaeology: if the people who occupy central positions in the network cease to be active, then it is likely that the overall network would fragment.
Assessing and mitigating this risk should be a high priority for future research in this area.

<!-- TODO: this should be backed up with a table or figure. The analysis seems to have got lost somewhere. Or just cut? -->
We also applied the same betweenness centrality algorithm on a subnetwork whose links are based only on issues and comments, and not code contributions. In this subnetwork, people who commit less code have higher betweenness scores. However, many of the people with high betweenness from the graph representing all contributions also appear here. These people who appear in both of these lists have a tendency to contribute as both committers and as commenters. This list also includes a series of contributors who never or rarely commit code. Although it is out of this study's scope a qualitative analysis of issues and comments may yield more insight on the kinds of contributions that each of these participants make.

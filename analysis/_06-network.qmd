# An emerging community of practice? {#sec-network}

```{r data-oarch_contributors}
oarch |>
  unnest(gh_contribs) |>
  drop_na(contributor) |>
  group_by(contributor) |>
  mutate(
    repo_owner = if_else(str_extract(repo, "[^/]+") == contributor, "own", "other")
  ) |>
  group_by(contributor, repo_owner) |>
  summarise(repos = n(), contribs = sum(contributions), .groups = "drop_last") |>
  pivot_wider(id_cols = c(contributor), names_from = repo_owner, 
              values_from = c(repos, contribs), values_fill = 0) |>
  mutate(
    repos = repos_other + repos_own,
    contribs = contribs_other + contribs_own,
    .after = contributor
  ) ->
  oarch_contributors
```

By contributing to shared repositories—whether with code (commits), issues, or comments—archaeologists using GitHub form a collaborative network which we can map using data from the GitHub API.
Here we consider two facets of this network: repositories connected by common contributors (the repository–repository graph), and users connected by contributions to common repositories (the user–user graph).
In both cases, number of contributions constitutes a natural measure of the strength or weight of the connection, which can be further broken down by type of contribution (commit, issue/pull request, or comment).

```{r data-graph}
oarch |>
  drop_na(gh_repo) |>
  unite(tags, c(tag1, tag2, tag3, tag4, tag5)) |>
  select(gh_repo, category, tags, gh_commits, gh_issues, gh_comments) ->
  oarch_graph

oarch_graph <- bind_rows(
  oarch_graph |>
    unnest(gh_commits) |>
    drop_na(author) |> # Apparently real commits, but we can't connect them
    group_by(repo, author) |>
    summarise(contrib = "commit", n_contrib = n(), .groups = "drop"),
  oarch_graph |>
    unnest(gh_comments) |>
    drop_na(author) |> # Repos with no comments
    group_by(repo, author) |>
    summarise(contrib = "comment", n_contrib = n(), .groups = "drop"),
  oarch_graph |>
    unnest(gh_issues) |>
    drop_na(author) |> # Repos with no issues
    group_by(repo, author) |>
    summarise(contrib = "issue", n_contrib = n(), .groups = "drop")
)

# Cleaning
oarch_graph |>
  rename(user = author) |>
  # Remove non-human users
  filter(!str_detect(user, coll("[bot]"))) |>
  filter(!user %in% c("ghost", "codecov-io", "coveralls", "codecov-commenter",
                      "gitter-badger", "dependabot-support")) ->
  oarch_graph

# Repo-user
tbl_graph(nodes_repos_users(oarch_graph),
          edges_user_to_repo(oarch_graph),
          directed = FALSE) |>
          mutate(
            degree = centrality_degree(),
            betweenness = centrality_betweenness(),
            subgraph = as_factor(group_components()),
            cluster = as_factor(group_edge_betweenness())
            ) ->
            oarch_graph_repo_user

# Repo-repo
tbl_graph(nodes_repos(oarch_graph),
          edges_common_users(oarch_graph),
          directed = FALSE) |>
  mutate(
    degree = centrality_degree(),
    betweenness = centrality_betweenness(weights = n),
    subgraph = as_factor(group_components()),
    cluster = as_factor(group_edge_betweenness())
  ) ->
  oarch_graph_repo_repo

# User-user
tbl_graph(nodes = nodes_users(oarch_graph), 
          edges = edges_common_repos(oarch_graph),
          directed = FALSE) |>
  mutate(
    degree = centrality_degree(),
    betweenness = centrality_betweenness(weights = n),
    subgraph = as_factor(group_components()),
    cluster = as_factor(group_edge_betweenness()) # <- slow!
  ) ->
  oarch_graph_user_user

# Network stats
graph_n_repos_total <- length(oarch_graph_repo_repo)
graph_n_users_total <- length(oarch_graph_user_user)

subgraphs_n_repos <- oarch_graph_repo_repo |>
  as_tibble() |>
  count(subgraph)

subgraphs_n_users <- oarch_graph_user_user |>
  as_tibble() |>
  count(subgraph)

clusters_n_repos <- oarch_graph_repo_repo |>
  as_tibble() |>
  count(cluster)

# Filter out isolates
oarch_graph_repo_repo <- filter(oarch_graph_repo_repo, degree > 1)
oarch_graph_user_user <- filter(oarch_graph_user_user, degree > 1)

# Network stats (ignoring isolates)
graph_n_repos <- length(oarch_graph_repo_repo)
graph_n_users <- length(oarch_graph_user_user)

# Export as gexf
write.gexf(igraph.to.gexf(oarch_graph_repo_user), 
           output = here("analysis/data/derived_data/oarch_repo_user.gexf"))
write.gexf(igraph.to.gexf(oarch_graph_repo_repo), 
           output = here("analysis/data/derived_data/oarch_repo_repo.gexf"))
write.gexf(igraph.to.gexf(oarch_graph_user_user), 
           output = here("analysis/data/derived_data/oarch_user_user.gexf"))
```

```{r fig-graph-repo-user}
#| fig-cap: Graph of open archaeology repositories and users connected by contributions. Darker edges indicate a great number of contributions. Node colour indicates membership of the largest clusters according to the edge–betweenness method [@girvan2002]. Excludes isolate nodes.
g_repo_user <- oarch_graph_repo_user |>
  group_by(cluster) |>
  mutate(cluster_n = n()) |>
  ungroup() |>
  mutate(
    cluster_rank = dense_rank(desc(cluster_n)),
    cluster = if_else(cluster_rank <= 7, cluster, NA)
  ) |>
  ggraph(layout = "fr", niter = 5000, grid = "nogrid") +
  geom_edge_link(aes(group = contrib, alpha = n_contrib)) +
  geom_point_interactive(aes(x, y, colour = cluster, shape = node_type, 
                             tooltip = node)) + 
  scale_edge_alpha(trans = "log", guide = guide_none()) +
  scale_colour_discrete(guide = guide_none()) +
  labs(shape = NULL) +
  theme(panel.background = element_rect(fill = "white"), 
        legend.position = "bottom")

girafe(ggobj = g_repo_user)
```

```{r fig-graph-repo-repo}
#| fig-cap: Graph of open archaeology repositories connected by common contributors. Darker edges indicate a great number of common contributors. Node colour indicates membership of the largest clusters according to the edge–betweenness method [@girvan2002]. Excludes repositories with only a single user.
g_repo_repo <- oarch_graph_repo_repo |>
  group_by(cluster) |>
  mutate(cluster_n = n()) |>
  ungroup() |>
  mutate(
    cluster_rank = dense_rank(desc(cluster_n)),
    cluster = if_else(cluster_rank <= 7, cluster, NA)
  ) |>
  ggraph(layout = "fr", niter = 5000, grid = "nogrid") +
  geom_edge_link(aes(alpha = n)) +
  geom_point_interactive(aes(x, y, colour = cluster, tooltip = repo)) + 
  scale_edge_alpha(trans = "log", guide = guide_none()) +
  scale_colour_discrete(guide = guide_none()) +
  theme(panel.background = element_rect(fill = "white"))

girafe(ggobj = g_repo_repo)
```

```{r fig-graph-user-user}
#| fig-cap: Graph of open archaeology users connected by contributions to common repositories. Darker edges indicate a great number of common repositories. Node colour indicates membership of the largest clusters according to the edge–betweenness method [@girvan2002]. Excludes users that have only contributed to a single repository.
g_user_user <- oarch_graph_user_user |>
  group_by(cluster) |>
  mutate(cluster_n = n()) |>
  ungroup() |>
  mutate(
    cluster_rank = dense_rank(desc(cluster_n)),
    cluster = if_else(cluster_rank <= 7, cluster, NA)
  ) |>
  ggraph(layout = "fr", niter = 5000, grid = "nogrid") +
  geom_edge_link(aes(alpha = n)) +
  geom_point_interactive(aes(x, y, colour = cluster, tooltip = user)) + 
  scale_edge_alpha(trans = "log", guide = guide_none()) +
  scale_colour_discrete(guide = guide_none()) +
  theme(panel.background = element_rect(fill = "white"))

girafe(ggobj = g_user_user)
```

<!-- Is there a network? How big is it? -->
Our data shows that there is a significant network of archaeologists collaborating on GitHub.
`r percent(graph_n_repos / graph_n_repos_total)` of repositories and `r percent(graph_n_users / graph_n_users_total)` of users in our dataset are connected to at least one other repository or user.
Of these, `r percent(max(subgraphs_n_repos$n) / graph_n_repos)` of repositories and `r percent(max(subgraphs_n_users$n) / graph_n_users)` of users belong to a single connected subgraph (@fig-graph-repo-user and @fig-graph-repo-repo).

<!-- Clustering within the network -->
To explore the topography of this network, we applied the edge–betweenness community detection method [@girvan2002] to delimit `r nrow(filter(clusters_n_repos, n > 1))` distinct clusters in the repository–repository network.
While many of these clusters are interconnected, some discrete components containing between 2-20 repositories appear as distinct from a primary core.
The core cluster is characterized by repositories whose contributors commit to projects other than their own, and it includes a smorgasbord of projects whose contributors share varied interests.

Likewise, we applied the same edge-betweenness community detection method to identify clusters in the user-user network, which reveal collaborative groupings.
We again see a complementary primary core connected to several more peripheral clusters, which are internally-cohesive and exhibit few connections with other peripheral clusters.
The central core bridges all the peripheral clusters.
The central core is not uniform, and comprises several relatively discrete sub-clusters representing collaborative sub-communities.
While these sub-clusters are internally cohesive, they exhibit enough connections to other members of the central core so as to not be considered as separate or peripheral clusters.

In both the repository-repository and user-user networks, the peripheral clusters correspond with either the connections surrounding specific projects or the series of repositories created by single individuals and sometimes also their close colleagues.
On the other hand, the central cores exhibit greater internal variety that may correspond with social connections and the formation of a complex software development community.
This is evident through the fact that many of the connections represented in the cores emerge from underlying professional partnerships, namely research labs (e.g. ISAA-Kiel) and special interest groups (CAA-SSLA).
Peripheral clusters that are connected to the central core by only a few relationships represent the sole (or perhaps initial) integration of lone developers into a broader community.

```{r tbl-repo-betweenness}
#| tbl-cap: Repositories ranked by centrality to the repository–repository network. Centrality is measured by node betweenness weighted by number of contributions.
oarch_graph_repo_repo |>
  as_tibble() |>
  arrange(-betweenness) |>
  slice(1:10) |>
  left_join(oarch, c("repo" = "gh_repo")) |>
  mutate(n_commits = map_int(gh_commits, nrow)) |>
  unite(tags, tag1:tag5, sep = "; ", na.rm = TRUE) |>
  transmute(rank = row_number(), repo, category, tags, n_commits) |>
  rename(repository = repo, commits = n_commits) |>
  rename_with(tools::toTitleCase) |>
  tt()
```

```{r fig-repo-betweenness-age-length}
#| fig-cap: Repository centrality by age (left) and length (right). Centrality is measured by node betweenness weighted by number of contributions.
left <- oarch_graph_repo_repo |>
  as_tibble() |> 
  left_join(oarch, by = c("repo" = "gh_repo")) |>
  mutate(
    age = map_int(gh_commits, \(x) min(today() - date(x$datetime)))
  ) |>
  ggplot(aes(age, betweenness)) +
  geom_point() +
  scale_x_log10() +
  scale_y_log10() +
  geom_smooth(method = "glm") +
  labs(x = "Repository age (days)", y = "Centrality") +
  theme_oarch()

right <- oarch_graph_repo_repo |>
  as_tibble() |> 
  left_join(oarch, by = c("repo" = "gh_repo")) |>
  mutate(
    length = map_int(gh_commits, nrow)
  ) |>
  ggplot(aes(length, betweenness)) +
  geom_point() +
  scale_x_log10() +
  scale_y_log10() +
  geom_smooth(method = "glm") +
  labs(x = "Number of commits", y = NULL) +
  theme_oarch()

left + right
```

<!-- Predictors of repo centrality -->
The repositories most central to the network as a whole (@tbl-repo-betweenness) include three lists and directories, including open-archaeo itself.
Three relate to making large data repositories accessible for analysis, and one is a very well-supported field recording application.
Community input is therefore centred on infrastructural projects, including those which index and publicize available tools and resources.
Moreover, three relate to radiocarbon data modelling and two relate to palaeoenvironment reconstruction, which reflects the fact that these have long been prominent foci of statistical software development in archaeology.

Repository centrality is predicted by the total number of commits it has received but, somewhat surprisingly, younger repositories rather than older ones tend to be more central (@fig-repo-betweenness-age-length).
Tentatively, we interpret this as an indication that the network has become more connected over time, but we leave a fuller analysis of temporal trends in collaborative activity to future work.

```{r fig-repo-betweenness-category-platform}
#| fig-cap: Mean repository centrality by category (top) and platform (bottom). Centrality is measured by node betweenness weighted by number of contributions.
top <- oarch_graph_repo_repo |>
  as_tibble() |> 
  left_join(oarch, by = c("repo" = "gh_repo")) |>
  group_by(category) |>
  summarise(betweenness = mean(betweenness)) |>
  mutate(category = fct_reorder(category, betweenness)) |>
  ggplot(aes(category, betweenness)) +
  geom_col() +
  scale_y_log10() +
  coord_flip() +
  labs(y = NULL, x = NULL) +
  theme_oarch()

bottom <- oarch_graph_repo_repo |>
  as_tibble() |> 
  left_join(oarch, by = c("repo" = "gh_repo")) |>
  drop_na(platform) |>
  group_by(platform) |>
  summarise(betweenness = mean(betweenness)) |>
  arrange(-betweenness) |>
  slice(1:7) |>
  mutate(platform = fct_reorder(platform, betweenness)) |>
  ggplot(aes(platform, betweenness)) +
  geom_col() +
  scale_y_log10(labels = NULL) +
  coord_flip() +
  labs(y = "Centrality →", x = NULL) +
  theme_oarch()

top / bottom
```

When comparing across categories and platforms, the highest mean centrality is seen in repositories that contain lists and datasets, standalone software, or packages and libraries, and in repositories based on Python, R or QGIS (@fig-repo-betweenness-category-platform).
Interestingly, these trends depart from the observed popularity of different categories and platforms in the open-archaeo dataset as a whole (see @sec-open-archaeology): standalone software is more central than packages/libraries, even though there are more of the latter by a significant margin.
This may be due to the fact that many packages are developed to support specific practices or use-cases (often inspired by personal need), or are designed to run relatively stable statistical functions that need not change over time.
These are therefore relatively stable and require little additional input after release.
On the other hand, as discussed in @sec-open-archaeology, standalone software tend to integrate multiple system components and may evolve over time to add new features or support new workflows.
Moreover, standalone software are generally rooted in longer-term and community-held objectives, and their development may therefore be backed by insitutions with funding and resources to support developers.

Despite being a minority language, Blender packages are more central than all other package platforms on average, but this is a statistical anomaly caused by uneven sampling.
R is naturally the platform with the next highest average centrality since it serves as a _lingua franca_ that draws developers from across the discipline.
Many of the QGIS plugins add various specialized features to the extensible GIS platform, and are therefore developed by interdisciplinary teams, which explains its high rank.
Python projects, which tend to be infrastructural or are of interest to members of other fields, are also highly ranked in terms of average centrality.
It should be noted that while Blender and QGIS plugins are written using the Python language, our intent while categorizing platforms was to get a sense of the developer ecosystems in which archaeological software engineers participate, rather than to simply gauge the popularity of different languages [@batist2023 2].
Our findings support the notion that there are significant development patterns when working across different languages and platforms, and further analysis to qualify these observation is warranted.

```{r fig-user-betweenness-contribs}
#| fig-cap: User centrality by total number of contributions. Centrality is measured by node betweenness weighted by number of contributions.
oarch_graph_user_user |>
  as_tibble() |> 
  left_join(oarch_contributors, by = c("user" = "contributor")) |>
  ggplot(aes(contribs, betweenness)) +
  geom_point() +
  scale_x_log10() +
  scale_y_log10() +
  geom_smooth(method = "glm") +
  labs(x = "Total contributions", y = "Centrality") +
  theme_oarch()
```

<!-- Predictors of user centrality -->
Centrality to the user–user graph is weakly predicted by a user's overall rate of activity, as measured by their total number of contributions (@fig-user-betweenness-contribs). 
We did not collect demographic data on users that appear in our dataset, but based on our own knowledge of the community we can observe that those highly central to the network tend to be employed in (junior) academic positions, or in a few cases in cultural heritage authorities, rather than specifically as research software engineers.
Such positions tend to not to actively reward or encourage software development, at least not on a par with more traditional academic outputs [@baxter2012], and are increasingly precarious [@cornelius-bell2021].
This obviously poses a serious risk to the sustainability and growth of open source software in archaeology: if the people who occupy central positions in the network cease to be active, then it is likely that the overall network would fragment.
Assessing and mitigating this risk should be a high priority for future research in this area.
